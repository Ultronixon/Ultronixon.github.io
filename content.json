{"pages":[],"posts":[{"title":"C Primer Plus笔记一","text":"第一章 初识C语言# 1.1，C语言程序运行机制 1.2，Lnix系统上的编译过程 1.3，windows下c程序编译 1.4 C标准的历史 1.5 使用C语言的7个步骤 1.6 编译和链接 1.7 GNU和LLVM项目 1.1，C语言程序运行机制# 源代码通过编译和链接这两部生成可执行码。 编译后的文件形成一个中间文件，最一般的形式为机器语言代码，放置在一个目标代码中，我们称为目标文件，虽然目标代码含有机器语言代码，不能执行，因为缺少第一元素启动代码（start-up code)，此代码相当于一个程序和系统之间的接口，这样目标代码就有可移植性，只有针对不同的系统，有相应的启动代码就可以使用。 目标代码缺少的第二元素是库例程代码，stdio.h, math.h等，这些库中存储着如printf(), exp()等的代码。 然后连接器将编译过的模块形成的目标代码结合在一起，形成可执行代码，当有多个模块时，如果要改变其中一个，就不必重新编译所有其他的模块，同时，连接器将程序与预编译的库代码结合起来（如上图）； 连接器的作用就是讲目标代码，启动代码和库代码结合在一起，并将它们放在单个文件中，即可执行文件。1.2，Lnix系统上的编译过程# inform.c的源代码只是程序的开始，而非结束。 Linux上需要使用GNU提供的gcc的公共C编译器编译C代码： gcc inform.c Linux下如果没有安装gcc，则需要进行安装。 1.3，windows下c程序编译#需要利用第三方提供的集成开发环境（IDE），进行程序编译，既可以编写，又可以编译运行。IDE可能提供了16位Windows程序，32位Windows程序，动态链接库文件（DLL）等让你选择。通常需要在IDE中创建一个项目（Project），以便随后向其中添加将要使用的源代码的名字，项目的类型很重要。一般通过.c来标识这是一个c文件，c++用.cpp来命名，大多数c代码都可以通过c++的程序运行。 windows的IDE下会出现程序运行一闪而过的情况，要看清程序运行的结果，可以在程序末尾，在return之前添加一行： getchar(); 该行读取一次按键，程序直到按下Enter键时才暂停。如果程序在某处需要暂停，也可以插入上面的代码。 1.4 C标准的历史#1、1978年Brian Kernighan 和Dennis Ritchie合著的《The C Programming Language》是公认的第一版C标准，通常称为K&amp;R C或者经典C。 2、1989年ANSI开发了一套标准，1990年ISO采用了该标准，称为ANSI C/ISO C。 3、1993年ANSI和ISO联合修改了C标准，最终发布C99. 4、ISO2011年发布了C11。 1.5 使用C语言的7个步骤#1、定义程序的目的； 2、设计程序； 3、编写代码； 4、编译； 5、运行程序； 6、测试和调试程序； 7、维护和修改程序； 跳过前两部的人往往浪费了更多的时间。 1.6 编译和链接#C编译器负责把代码翻译成特定的机器语言。此外，C的编译器还将源代码与C库的代码合并成最终的可执行程序。，更准确地说，应该是由一个本称为连接器的程序来链接库函数。 编译器把源代码转化成中间代码，连接器把中间代码和系统启动代码和库代码合并，生产可执行的文件。 1.7 GNU和LLVM项目#gcc和clang。","link":"/2020/05/03/C-primer-plus-chapter1/"},{"title":"C primer plus笔记二","text":"第二章 C语言的概述# 2.1 main函数写法 2.2 注释 2.3 声明 2.4 赋值 2.5 实参和形参 2.6 return语句 2.7 提高程序可读性的技巧 2.8 程序的状态 2.9 关键字和保留标识符 2.1 main函数写法#1int main(void) 是现在的C标准的写法。 1main() C90可以勉强接受这样的写法，但是C99和C11都不允许这样写 1void main() 有些编译器允许这么写，但是所有的标准都没有认可过这样的写法，不可取。 2.2 注释#123456/*注释主要是提供程序的可读性*//*多行--------------*///单行注释，避免注释标注的丢失。只有C99和C11才支持这一特性。 2.3 声明#C语言中变量必须先声明，再使用。 这样做由一下几个原因： 1、把所有的变量放在一起（C99和C11以前的规则是把声明放在块的顶部，C99和C11允许在任何位置进行声明，只要是在变量使用之前）有助于读者查找和理解程序的用途。尤其是变量名字有意义的时候。 2,、声明变量能够促使我们在编程之前做计划。 3、声明变量有助于发现隐藏在程序中的小错误。 4、如果不声明，程序无法通过编译。 2.4 赋值#12int num;num=1; 在执行变量声明时，编译器在计算机内存中为num预留了空间，执行赋值表达式语句时，把值储存在之前预留的位置。 2.5 实参和形参#实际参数是传递给函数的特定值； 形式参数是函数用于储存值得变量。 2.6 return语句#如果遗漏main()函数中的return语句，程序在运行至最外面的右花括号（}）的时候会返回0。所以在main函数中是可以遗漏的，但是其他非void声明的函数不能遗漏，但是为了保持良好的编码习惯，最后都不要以后return语句。 2.7 提高程序可读性的技巧#1、选择有意义的函数名和变量名，并写注释，两者相互配合，避免重复啰嗦。 2、在函数中用空行隔开概念上的多个部分。 3、每条语句各占一行。 2.8 程序的状态#1、可以跟踪一小部分循环，看看程序是否按照预期的方式执行， 2、定位语义错误还可以在程序中的关键部位插入额外的printf()语句，以监视制定变量值得变换。 3、使用调试器。 2.9 关键字和保留标识符#下表为ISO C关键字。粗体为C90新增的，斜体为C99新增的，粗斜体为C11新增的。 1 2 3 4 auto extern short while break float signed _Alignas case for sizeof _Alignof char goto static _Atomic const if struct _Bool continue inline switch _complex default int typedef _Generic do long union _Imaginary double register unsigned _Noreturn else restrict void _Static_assert enum return volatile _Thread_local 关键字是C的词汇。变量命令和函数命名应该避开，以免引起歧义。","link":"/2020/05/04/C-primer-plus-chapter2/"},{"title":"C primer plus笔记三","text":"第三章 数据和C# 3.1 数据类型关键字 3.2 C语言基本数据类型 3.3 数据类型的大小 3.4 使用数据类型 3.5 转义序列示例 3.6 刷新输出-屏幕打印的机制 3.1 数据类型关键字# 如果数据是常量，编译器一般会按照用户书写的方式识别类型，如7,为int型，7.0为float型； char也可以表示较小的整数； 一字节Byte=8位（bit）可以存放2的8次幂的整数。 整数与浮点数的存储方式不同； 在一个值后面加小数点以后，就变成了浮点数，虽然值相同，但是存储方式已经不同了，如7和7.0. 对于一些算数运算（如，两个很大数相减），浮点数损失的精度更多。 浮点数有小数部分，任何小的区间里都是无穷多小数位，因此，计算机浮点数存储只是真值得近似值，尤其两个很大的浮点数的算数运算，损失精度更多 3.2 C语言基本数据类型#目前一般的情况是，longlong类型为64位，long类型为32位，short类型为16位，int类型为16位或32位（依机器的自然字大小而定）。但原则上，这4种类型代表4个不同大小的数值。 C语言标准规定了每种基本数据类型的最小取值范围。对应于16位单位，short类型和int类型的最小取值范围为-32767到32767；对应于32位单位，long类型的最小取值范围为-2147483647到2147483647。 对于unsigned short类型和unsigned int类型，最小取值范围为0到65535； 对于unsigned long类型，最小取值范围为0到4294967295。long long类型是为了支持对64位的需求，最小取值范围是数目可观的-9223372036854775807到9223372036854775807；unsigned long long类型的最小取值范围为0到18446744073709551615。如果您是在开支票，按照美国的写法这个数是18个百万的3次方，446个千的5次方，744个万亿，73个十亿，709个百万，551个千，和615。但谁会去数呢？ 3.2.1 int# 当使用int类型不能表示一个数而使用long类型可以做到时，使用long类型。但是，在long类型大于int类型的系统中，使用long类型会减慢计算，所以没有必要时不要使用long类型。如果是在long类型等于int类型的系统中编写代码，当确实需要32位整数时，应使用long类型（而不是int类型），以便使程序被移植到16位机器上后仍然可以正常工作。 与之类似，如果需要64位整数，您应使用long long类型。一些计算机已经使用了64位处理器，并且64位的服务器、工作站甚至桌面系统不久将十分普遍。 在int为32位的系统上，如果需要16位的值，那么使用short类型可以节省存储空间。通常，只有当程序使用了使系统可用内存很紧张的较大的整数数组时，节省存储空间才是重要的。使用short类型的另一个原因是计算机中的一些硬件寄存器是16位的。 1、16位计算机的int型的范围是-32768—32767。 3.2.2 8进制和16进制#8进制和16进制都是2的幂，应用起来很方便，65536在16位机中经常出现，十六进制正好是10000，十六进制恰好可以由4位二进制数表示，如0x3位二进制的0011,0x5位二进制的0101，于是0x35位二进制的00110101,0x53为二进制的01010011，这样的关系使得二进制和十六进制之间转换特别方便，十六进制前缀“0x”或者”0X“表示。前缀”0“表示8进制。 十进制显示用%d,八进制显示用%o,十六进制显示用%x。 要显示不同进制整数的前缀，则必须用“#”，如%#o,%#x,分别显示八进制和十六进制的前缀。 3.2.3 其他整数类型#C语言提供了3个附属关键字修饰基本整数类型：short,long,unsigned. 因为C语言规定了short占用的存储空间不能多于int，long占用的不能少于int，这样规定是为了适应不同的机器，为了存储64位的整数，才加入long long类型。 个人计算机最常见的设置是：long long64位，long32位，short16位，int16位或者32位。 那些long占用的空间比int大的系统，使用long类型会减慢计算速度。因此如非必须，请不要使用long类型，如long类型和int类型占用的空间相同的机器上编码，当确定要使用32位的整数时，应该使用long而不是int，以便程序的可移植性。 3.2.4 整数的溢出#无符号整数j像一个汽车里程指示表，当达到最大值时，它将溢出到起始点。整数i也是同样。它们的主要区别是unsigned int变量j的起始点是0（正像里程指示表那样），而int变量i的起始点则是一2147483648。注意到当i超过（溢出）它的最大值时，系统并没有给出提示，所以编程时您必须自己处理这个问题 12345678910111213141516#include&lt;stdio.h&gt;int main(void){ int i=2147483647; unsigned int j=4294967295; printf(\"%d %d %d\\n\",i,i+1,i+2); printf(\"%u %u %u\\n\",j,j+1,j+2); return 0;}/*运行结果2147483647 -2147483648 -21474836474294967295 0 1*/ 整数超出范围以后会从头开始。 3.2.5 打印不同类型数据要用对应的类型符#12345678910111213141516171819202122232425262728293031323334/*print2.c----更多printf函数的性质*/#include&lt;stdio.h&gt;int main(void){ unsigned int un=3000000000; short end=200; long big=65537; long long verybig=12345678908642; printf(\"The size of int is \\t%d\\n\",sizeof(int)); printf(\"The size of short is \\t%d\\n\",sizeof(short)); printf(\"The size of long is \\t%d\\n\",sizeof(long)); printf(\"The size of long long is \\t%d\\n\",sizeof(long long)); printf(\"The size of unsigned is \\t%d\\b\\n\",sizeof(unsigned)); printf(\"un=%u and not int type print result %d\\n\",un,un); printf(\"end=%hd(printed hd),and int print it is %d\\n\",end,end); printf(\"big=%ld(printed ld) and not %hd(hd printed)\\n\",big,big); printf(\"verybig=%lld(lld printed) and not %ld(ld printed)\\n\",verybig,verybig); return 0;}/*运行结果：The size of int is 4The size of short is 2The size of long is 4The size of long long is 8The size of unsigned is 4un=3000000000 and not int type print result -1294967296end=200(printed hd),and int print it is 200big=65537(printed ld) and not 1(hd printed)verybig=12345678908642(lld printed) and not 1942899938(ld printed)*/ 可以看出，用小于该数据类型的数据类型符号打印时，在数据超过该类型的情况下，就会有截短效应。 根据打印的每种类型的大小看，int类型为32位，short位16位，long也为32为，long long为64位。 在short类型和int大小不同的计算机中，编译器会把short当成int来存储，因为用int类型的的参数传递更快。 3.2.6 char 类型#ASCII的范围是0-127，只需7位二进制数可以表示。 通常char被定义为8位整数，但是C语言会爆炸char类型足够大，以存储系统（实现C语言的系统）的基本字符。 1、char类型用于存储字符，用但单引号初始化‘A’。 2、单引号内的单个字符为字符常量。 3、丢掉单引号，系统会认为是一个变量，用双引号则系统会认为是一个字符串。 4、char类型可以直接用整数赋值来初始化。 5、\\a是发出一声警报； 6、char类型打印用%c。 7、处理小整数时，可在char前面加signed和unsigned，如果单独处理字符，不用加符号。 3.2.7 _Bool类型#C99添加的数据类型，布尔值，只有0和1,0表示false,1表示true。只占1bit。 3.2.8 可移植数据类型：stdint.h和inttypes.h#某些整数类型名在不同系统中的功能不一样，比如int有可能是32位，有可能是16位。为了实现代码的可移植性，保证整数类型声明功能在不同操作系统的一致性。c99加入了上述两个头文件。 精确宽度整数类型 stdint.h头文件定义了很多新的类型名，例如int32_t表示32位无符号的整数类型，在32位系统中，int32_t就是int的别名，而在int16位，long32位的系统中，int32_t就是long的别名。编译器会把int或者long替换成与当前系统匹配的类型； 最小宽度类型 如果系统不支持精确宽度整数类型，其中定义了一些别名保证所表示的类型一定是只是有指定宽度的最小整数类型，这组类型集合被称为最小宽度类型。例如int_least8_t是可容纳8位有符号整数的类型中宽度最小的类型的一个别名。 最快最小宽度类型 c99和c11定义了一组可使得计算机达到最快的类型的集合，称为最快最小宽度类型。例如int_fast8_t 被定义为系统中对8位有符号值而言运算最快的整数类型的别名； 最大整数类型 c99定义了最大有符号整数类型intmax_t,可存储任何有效的有符号整数值。这些类型可能比long long,unsigned long类型更大，因为C编译器除了实现编制规定的类型外，还可利用C语言实现其他类型，例如，一些编译器在标准引入long long类型之前，就已经提前实现了该类型。 可移植别名的输入输出 inttypes.h中定义了一系列字符串宏用来实现可移植数据类型的输入输出。例如PRId32字符宏，代表打印32位有符号值得合适转换说明符（如d或者l）。 1234567891011121314151617/*altnames.c --可移植整数类型名*/#include &lt;stdio.h&gt;#include &lt;inttypes.h&gt; //支持可移植类型int main(void){ int32_t me32; me32 = 45933945; printf(\"Fist, assume int32_t is int: \"); printf(\"me32 = %d\\n\", me32); printf(\"Next, let's no make any assumptions.\\n\"); printf(\"Instead, use a \\\"macro\\\" from inttypes.h: \"); printf(\"me32 = %\" PRId32 \"\\n\", me32); //PRId32宏定义在inttypes.h头文件中， // %\" PRId32 \" 等价于 %\" d \" 等价于%d, 因为本系统int32_t就是int的别名，因为int是32位的 return 0;} 上面在我电脑上输出是: 123Fist, assume int32_t is int: me32 = 45933945Next, let's no make any assumptions.Instead, use a \"macro\" from inttypes.h: me32 = 45933945 《C Primer Plus》附录B中对扩展整数类型进行了说明。 3.2.9 float、double和long double#float 能够表示至少6位有效数字，大小在$10^{-37}~10^{+37}$，占32位，24位表示有效数字，其余8位表示符号和指数; double类型能够表示13位有效数字，大小与float类型一样，占用64位，一般系统下8位表示符号和指数，其余56位用来表示有效数字，有些则会让指数更大； long double，C只保证至少跟double类型的精度相同。 默认情况下，编译器嘉定浮点型常量是double类型的精度。 12float sum；sum=2.0+4.0; 如上面语句，一般常量2.0和4.0系统都会存储成double双精度类型，然后进行计算，再把结果截短乘float类型给变量sum。 在浮点数后面加f或者F可以覆盖默认的设置，编译器会将浮点数看做float类型。 在浮点数后面加l或者L使得浮点数成为long double类型。 没有后缀的浮点型常量是double类型 用%f打印十进制计数法的float和double类型的浮点数，%e打印指数计数法的浮点数。如果系统支持16进制浮点，可用a和A代替e和E， long double可以用%Lf,%Le,%La转换说明。 给那些为在函数原型中显式说明参数类型的函数（如printf）传递参数时，C编译器会自动把float类型转换成double 类型。 123456789101112131415#include&lt;stdio.h&gt;int main(void){ float aboat=32000.0; double abet=2.14e9; double dip=5.32e-5; printf(\"%f can be written %e\\n\",aboat,aboat); //下一行c99标准才支持，%a表示十六进制的浮点数 printf(\"And it's %a in hecadecimal, powers of 2 natation\\n\",aboat); printf(\"%f can be written %e\\n\",abet,abet); printf(\"%Lf can be written %Le\\n\",dip,dip); return 0;} 123432000.000000 can be written 3.200000e+004And it's 0x1.f40000p+14 in hecadecimal, powers of 2 natation2140000000.000000 can be written 2.140000e+0090.000053 can be written 5.320000e-005 浮点值得上溢和下溢： 12345678910/*假设float的最大值是3.4E38，看看上溢和*/#include&lt;stdio.h&gt;int main(void){ float toobig=3.4E38*100.0f; printf(\"%e\\n\",toobig); return 0;} 11.#INF00e+000 一般现在C标准规定，这种情况下。printf显示inf或者infinity。 除一个很小的数的时候，如果指数位足够小，再继续除以整数，则会向右移动指数部分，空出一个二进制位，并丢弃最后一个二进制数，损失一位精度。这样的值称为subnormal浮点值，浮点值下溢会丢失精度，如果除以一个非常大的值，则会失去所有精度，所有位变成0；c库已经提供了用于检测计算是否会产生低于正常值的函数。 Nan（Not a number), 用来表示无效值，比如sin(x)的值小于1，如果传入大于1的参数，函数行为未定义，函数将返回Nan. 浮点数舍入错误: 12345678910111213/* floaterr.c--demonstrates round-off error *///一个数加1，再减去这个数，返回的并不是1#include &lt;stdio.h&gt;int main(void){ float a,b; b = 2.0e20 + 1.0; a = b - 2.0e20; printf(\"%f \\n\", a); return 0;} 14008175468544.000000 上面需要20位有效数字才能完成精确计算，而float有效精度时6-7位。 3.2.10 复数和虚数类型#c99和c11都支持虚数和复数，但都是可选项。 复数：float _Complex,double _Complex,long double _Complex 虚数：float _Imaginary,double _Imaginary,long double _Imaginary 如果包含了complex.h,就可以用complex替换_Complex，imaginary替换_Imaginary，用I表示-1的平方根。 1234567891011//complex.h 头文件的使用，里面定义了很多支持复数和虚数的函数#include &lt;stdio.h&gt;#include &lt;complex.h&gt;int main(void) { double complex cmp =1.3+2.3*I; printf(\"%f + %fi\\n\", creal(cmp), cimag(cmp)); return 0; } 11.300000 + 2.300000i 更多复数和虚数的内容可参考： complex.h复数及其运算 3.3 数据类型的大小#在limits.h和float.h头文件中有类型限制的相关信息。 3.4 使用数据类型#把一个类型的数值初始化给不同类型的变量时，编译器会把数值转换成与变量匹配的类型，这样可能会导致部分数据丢失。如: 12int const = 12.44 \\\\结果就是丢失小数部分float pi = 3.141592653 \\\\丢失6位以后的数字 初始化数值要和变量类型匹配，可以通过规则化命名从变量名看出类型，例如f_const表示一个float类型的变量。i_num表示int类型的变量。 3.5 转义序列示例#12345678910111213141516171819/* escape.c -- uses escape characters */#include &lt;stdio.h&gt;int main(void){ float salary; printf(\"\\aEnter your desired monthly salary:\");/* 1 */ //一声警报后输出Enter your desired monthly salary printf(\" $_______\\b\\b\\b\\b\\b\\b\\b\"); /* 2 */ //光标退回到$后面，---并不会被擦除 scanf(\"%f\", &amp;salary); printf(\"\\n\\t$%.2f a month is $%.2f a year.\", salary, salary * 12.0); /* 3 */ //另起一行，一个tab后输出 printf(\"\\rGee!\\n\"); /* 4 */ // /r可以回头行开头来输出Gee return 0;} 123nter your desired monthly salary: $20000___Gee! $20000.00 a month is $240000.00 a year. 3.6 刷新输出-屏幕打印的机制#printf()会把输出发送到buffer(缓冲区)中，然后在以下三个条件的时候会将缓冲区中的内容打印到屏幕上，这个过程叫做刷新缓冲区。C规定在： 缓冲区满了 遇到换行（\\n） 需要输入（如scanf(),getchar()等) 这个三个条件满足其中一个时，刷新缓冲区。上面就是在前两个printf()遇到需要输出salary的scanf()函数时，前两个printf的内容才输出到屏幕上。 还可以使用fflush()函数刷新缓冲区，后面会讲到。","link":"/2020/05/04/C-primer-plus-chapter3/"},{"title":"C primer plus笔记四","text":"第四章 字符串和格式化输入输出# 4.1 示例程序 4.2 字符串 4.3 常量和C预处理 4.4printf()函数 4.5 scanf（）函数 4.6 printf和scanf的*修饰符 4.1 示例程序#12345678910111213141516171819202122232425// talkback.c -- nosy, informative program #include &lt;stdio.h&gt;#include &lt;string.h&gt; // 提供strlen()函数原型#define DENSITY 62.4 // human density in lbs per cu ftint main(){ float weight, volume; int size, letters; char name[40]; // name is an array of 40 chars printf(\"Hi! What's your first name?\\n\"); scanf(\"%s\", name); printf(\"%s, what's your weight in pounds?\\n\", name); scanf(\"%f\", &amp;weight); size = sizeof name; letters = strlen(name); volume = weight / DENSITY; printf(\"Well, %s, your volume is %2.2f cubic feet.\\n\", name, volume); printf(\"Also, your first name has %d letters,\\n\", letters); printf(\"and we have %d bytes to store it in.\\n\", size); return 0;} scanf()的变量是数组的时候不需要前面加&amp;，数组名就是数组首地址。 4.2 字符串# 字符串存储末尾有空字符\\0表示字符串结束，所以实际存储的长度要比字符串多1； 单个字符存储在char变量里，字符串存储在数组里； %s转换说明，scanf()遇到空格、制表符和换行符就停止读入，因此只读取字符串中的一个单词，而不是一整句，其他函数如fget()可以读取一句。 strlen()函数显示字符串的字符个数，不包括结尾的空字符。 sizeof函数在计算字符变量的时候，把结尾的空字符也计算在内。 为了适应不同系统sizeof()和strlen()函数的返回值类型（有可能是unsigned int,unsigned long. unsigned long long), 提供程序的可移植性，C99，C11专门为sizeof(),strlen()函数添加了转换说明符%zd，有的编译器并不支持这一特性，可以用%u,%lu代替。 sizeof()参数是类型时必须用括号，如果是特点量，可以不用括号，如sizeof name,sizeof 5.225,但是为了代码的可读性还是都有括号的好。 4.3 常量和C预处理# #define可以声明常量，按照C的惯例，声明的常量要用大写字母表示。 C90 添加了const关键字，限定了一个变量为只读。const比#define更加灵活，可以在变量使用之前声明。 明示常量（limits.h,float.h) 明示常量 含义 CHAR_BIT char类型的位数 CHAR_MAX char类型的最大值 CHAR_MIN char类型的最小值 SCHAR_MAX signed char类型的最大值 SCHAR_MIN signed char类型的最小值 UCHAR_MAX unsigned char类型的最大值 SHRT_MAX short类型最大值 SHRT_MIN short类型最小值 USHRT_MAX unsigned short最大值 INT_MAX int类型最大值 INT_MIN int类型最小值 UINT_MAX unsigned int类型最大值 LONG_MAX long类型最大值 LONG_MIN long类型最小值 ULONG_MAX unsigned long类型最大值 LLONG_MAX long long类型最大值 LLONG_MIN long long最小值 ULLONG_MAX unsigned long long最大值 上面是limits.h中的一些明示常量。 下面是floats.h中的一些明示常量，表示float和double类型的精度。 明示常量 含义 FLT_MANT_DIG float类型的尾数位数 FLT_DIG float类型的最少的有效数字位数（十进制） FLT_MIN_10_EXP 带全部有效数字的float 类型的最小负指数（以10位底） FLT_MAX_10_EXP float类型的最大正指数（以10为底） FLT_MIN 保留全部进度的float类型的最小正数 FLT_MAX float类型的最大正数 FLT_EPSLION 1.00和比1.00大的最小float类型值之间的插值 下面看看我的电脑以上明示常量的情况： 1234567891011121314151617181920212223242526272829303132333435//defines.c---ʹ打印limits.h和float.h中的一些明示常量#include&lt;stdio.h&gt;#include&lt;limits.h&gt;#include&lt;float.h&gt;int main(void){ printf(\"Some int. number limits for this system:\\n\"); printf(\"-------------------------------------------\\n\"); printf(\"CHAR_BIT:\\t%d\\n\",CHAR_BIT); printf(\"CHAR_MAX:\\t%d\\n\", CHAR_MAX); printf(\"CHAR_MIN:\\t%d\\n\", CHAR_MIN); printf(\"SCHAR_MAX:\\t%d\\n\", SCHAR_MAX); printf(\"SCHAR_MIN:\\t%d\\n\", SCHAR_MIN); printf(\"UCHAR_MAX:\\t%d\\n\", UCHAR_MAX); printf(\"INT_MAX:\\t%d\\n\", INT_MAX); printf(\"INT_MIN:\\t%d\\n\", INT_MIN); printf(\"UINT_MAX:\\t%u\\n\", UINT_MAX); printf(\"LONG_MIN:\\t%ld\\n\", LONG_MIN); printf(\"LONG_MAX:\\t%ld\\n\", LONG_MAX); printf(\"ULONG_MAX:\\t%lu\\n\", ULONG_MAX); printf(\"LLONG_MAX:\\t%lld\\n\", LLONG_MAX); printf(\"LLONG_MIN:\\t%lld\\n\", LLONG_MIN); printf(\"ULLONG_MAX:\\t%llu\\n\", ULLONG_MAX); printf(\"Some float number limits for this system:\\n\"); printf(\"-------------------------------------------\\n\"); printf(\"FLT_MANT_DIG:\\t%d\\n\",FLT_MANT_DIG); printf(\"FLT_DIG:\\t%d\\n\",FLT_DIG); printf(\"FLT_MIN_10_EXP:\\t%d\\n\",FLT_MIN_10_EXP); printf(\"FLT_MAX_10_EXP:\\t%d\\n\",FLT_MAX_10_EXP); printf(\"FLT_MIN:\\t%f\\n\",FLT_MIN); printf(\"FLT_MAX:\\t%f\\n\",FLT_MAX); printf(\"FLT_EPSLION:\\t%f\\n\",FLT_EPSILON); return 0;} 下面是我电脑上的输出： 1234567891011121314151617181920212223242526Some int. number limits for this system:-------------------------------------------CHAR_BIT: 8CHAR_MAX: 127CHAR_MIN: -128SCHAR_MAX: 127SCHAR_MIN: -128UCHAR_MAX: 255INT_MAX: 2147483647INT_MIN: -2147483648UINT_MAX: 4294967295LONG_MIN: -2147483648LONG_MAX: 2147483647ULONG_MAX: 4294967295LLONG_MAX: 9223372036854775807LLONG_MIN: -9223372036854775808ULLONG_MAX: 18446744073709551615Some float number limits for this system:-------------------------------------------FLT_MANT_DIG: 24FLT_DIG: 6FLT_MIN_10_EXP: -37FLT_MAX_10_EXP: 38FLT_MIN: 0.000000FLT_MAX: 340282346638528860000000000000000000000.000000FLT_EPSLION: 0.000000 4.4printf()函数#转义说明#下表示printf()函数转义说明及其打印的输出结果： 转义说明 输出 %a 浮点数、十六进制数和p计数法（c99/c11) %A 浮点数、十六进制数和p计数法（c99/c11) %c 单个字符 %d 有符号十进制整数 %e 浮点数，e计数法 %E 浮点数，e计数法 %f 浮点数，十进制计数法 %g 根据值的不同，自动选择%f或者%e，%e格式用于指数小于-4或者大于等于精度时 %G 根据值的不同，自动选择%f或者%E,%E格式用于指数小于-4或者大于等于精度时 %i 有符号十进制整数（与%d相同） %o 无符号八进制整数 %p 指针 %s 字符串 %u 无符号十进制整数 %x 无符号十六进制整数，0f开头 %X 无符号十六进制整数，0F开头 %% 打印一个% 修饰符#在转义说明的基础上，通常需要对格式进行 修饰，如定义位数，对齐等，下标时转义说明修饰符的含义： 修饰符 含义 - 可以不使用或者使用多个标记。-表示左对齐 + 表示带符号的数，正数前面+，负数- 空格 带符号，正数为空格，负数-（正数用空格代替+） # 把结果转换成另外一种计数形式，如果是%o，就以0前缀，%x,就以0x前缀，%X,就以0X前缀 ；对于所有浮点格式，#保证了及时后面没有任何数字，也会打印一位小数点字符；对于%g和%G,防止结果后面的0被删除 0 对于数值格式，用前导0代替空格填充字段宽度，对于整数格式，如果出现标记或者指定精度，则忽略该标记 .数字 表示精度。对于%f,%e,%E表示小数点右边打印位数；对于%g,%G表示有效数字的最大位数；对于%s表示打印字符的最大数量；对于整数表示打印整数的最小位数，可以用前导0满足打印位数；只使用.,则前后跟随一个0. h 和整数转换一起用，表示short int或者unsigned short int类型值，%hd,%hu hh 跟整数转换一起用，表示signed char或者unsigned char类型的值 j 和整数转换一起用，表示intmax_t和uintmax_t类型的值（该类型在stdint.h中) l 和整数转换说明一起用，表示long int或者unsigned long int类型，如：%ld, %8lu ll 和整数转换说明一起用，表示long long int或者unsigned long long int类型，如：%lld, %8llu（c99） L 和浮点转换说明一起，表示long double类型 t 和整数转换说明一起，表示ptrdiff_t类型，即两个指针的插值类型（c99） z 和整数转换一起，表示size_t类型的值，size_t是sizeof()的返回类型（c99） C标准值规定了sizeof()返回的是无符号类型，到时不同系统，可能返回的类型不同，为了代码可移植性，c99在stdio.h中用size_t定义系统使用sizeof()返回的类型，并用修饰符z打印它。 12345678910111213//整数打印实例/* width.c -- field widths */#include &lt;stdio.h&gt;#define PAGES 931int main(void){ printf(\"*%d*\\n\", PAGES); printf(\"*%2d*\\n\", PAGES); //最少打印2位，超出范围则忽略 printf(\"*%10d*\\n\", PAGES);//默认右对齐 printf(\"*%-10d*\\n\", PAGES);//负号左对齐 return 0;} 1234*931* //最少打印2位，超出范围则忽略*931* //最少打印2位，超出范围则忽略* 931* //默认右对齐*931 * //负号左对齐 123456789101112131415161718//floats.c--一些浮点型修饰符的组合#include&lt;stdio.h&gt;int main(void){ const double RENT=3852.99;//const 变量（只读） printf(\"*%f*\\n\",RENT); printf(\"*%e*\\n\",RENT); printf(\"*%4.2f*\\n\",RENT); printf(\"*%3.1f*\\n\",RENT); printf(\"*%10.3f*\\n\",RENT); printf(\"*%10.3E*\\n\",RENT); printf(\"*%+4.2f*\\n\",RENT); printf(\"*%010.2f*\\n\",RENT); return 0;} 123456789//运行结果*3852.990000* //默认打印6位小数*3.852990e+003* *3852.99* //最小字段宽度4，打印2位小数*3853.0* //最小字段宽度3，打印1位小数* 3852.990* //最小字段宽度10，打印3位小数*3.853E+003**+3852.99* //带符号*0003852.99* //前导补0 12345678910//flags.c---演示一些格式标记#include&lt;stdio.h&gt;int main(void){ printf(\"%x %X %#x\\n\",31,31,31); printf(\"**%d**% d**% d**\\n\",42,42,-42); printf(\"**%5d**%5.3d**%05d**%05.3d**\\n\",6,6,6,6); return 0;} 1234//运行结果1f 1F 0x1f**42** 42**-42**//%d前面加一个空格，如果是正数，则加一个空格，如果是负数，则不生成空格，用负号占位** 6** 006**00006** 006**//0和格式符同时出现时，宽度格式符起作用 转换说明的意义#12345678910111213141516//intconv.c--一些不匹配的整数转换#include&lt;stdio.h&gt;#define PAGES 336#define WORDS 65618int main(void){ short num=PAGES; short mnum=-PAGES; printf(\"num as short and unsigned short:%hd %hu\\n\",num,num); printf(\"-num as short and unsigned shot:%hd %hu\\n\",mnum,mnum); printf(\"num ans int and char:%d %c\\n\",num,num); printf(\"WORDS as int, short, and char:%d %hd %c\\n\",WORDS,WORDS,WORDS); return 0;} 1234567//运行结果num as short and unsigned short:336 336-num as short and unsigned shot:-336 65200//系统使用==二进制补位==来表示有符号的整数，其中//65535表示-1,65534表示-2，以此类推。所以不同的类型一个数可以解释出不同的结果。num ans int and char:336 P//超出范围的char类型，按256取模，余数表示的就是char类型字符WORDS as int, short, and char:65618 82 R//short表示int的时候，只取int的最后2个字节，其实//就是按65536取模 123456789101112131415//floatconv.c---不匹配的浮点转换#include&lt;stdio.h&gt;int main(void){ float n1=3.0; double n2=3.0; long n3=2000000000; long n4=1234567890; printf(\"%.1e %1e %.1e %.1e\\n\",n1,n2,n3,n4); printf(\"%ld %ld\\n\",n3,n4); printf(\"%ld %ld %ld %ld\\n\",n1,n2,n3,n4); return 0;} 12345678//运行结果3.0e+000 3.000000e+000 3.1e+046 8.5e+257//第一行，%e输出时，默认目标是double型，会查看8个字节，其实n3是4字节存放的。2000000000 12345678900 1074266112 0 1074266112//%ld打印浮点数会失败。后面的%ld打印long类型也失败了。是因为函数调用的原因//传入函数的参数的值被存放在栈里，n1，n2都站8个字节，n3，n4站4个字节，但在按转换符输出的时候，//%ld是按照4个字节4个字节读取，所以后面的long类型也不能正确输出。 printf函数返回值#printf函数输出正确的情况下返回输出字符的个数，如果输出失败返回一个负值。可以用来检查输出错误。 float类型作为printf参数打印时，会被转换成double`类型 打印字符串断行的方法#有三种方法： 多个printf函数出输 用\\断开，下一行不能有缩进 多个双引号括起来，之间会间隔，不同双引号可以换行，同时可以缩进 123456789101112/* longstrg.c -- printing long strings */#include &lt;stdio.h&gt;int main(void){ printf(\"Here's one way to print a \"); printf(\"long string.\\n\"); printf(\"Here's another way to print a \\long string.\\n\"); printf(\"Here's the newest way to print a \" \"long string.\\n\"); /* ANSI C */ return 0;} 123Here's one way to print a long string.Here's another way to print a long string.Here's the newest way to print a long string. 4.5 scanf（）函数#123456789101112131415//input.c---如何使用&amp;#include&lt;stdio.h&gt;int main(void){ int age; float assets; char pet[30]; printf(\"Enter your age,assets, and favorite pet.\\n\"); scanf(\"%d %f\",&amp;age,&amp;assets); scanf(\"%s\",pet);\\\\数组后面不加&amp; printf(\"%d $%.2f %s\\n\",age,assets,pet); return 0;} 浮点数读取的区别#对于float类型和double类型，printf都用那几个转换说明，但是scanf()把读点说明符用于float型，对于double类型要使用l进行修饰； 读取间隔的规定#多个输入时候，相互之间的间隔是至少一个空格，或者换行符或者制表符。唯一的另外是%c,它会读取每个字符，包括空格 读取机制# scanf会把不符合的字符放回输入，所以下次读取输入时，还是从上一次丢弃的数据开始读取； 使用字段宽度时，在到达宽度或者遇到空格时停止 如果第一个非空字符是A,scanf会停在那里，把A放回输入，不会赋值给变量，下一次程序读取的字符是A，如果用%d读取，程序将一直无法越过A。 如果带多个转换说明读取，在第一个出错的地方结束读取 %s读取时，跳过空白字符读取直到下一个空白字符停止，也就是只能读取一个单词，固定宽度也无法让它读取多个单词，并且把字符串放进数组以后会自动在结尾加上\\0,让其成为字符串。 getchar()可以读取单个字符，fgets()可以读取带空格的字符串 格式字符串中间可以加入普通字符，如scanf(&quot;%d,%d&quot;, &amp;n, &amp;m),输入时也必将两个数中间加, scanf(&quot;%c&quot;,&amp;ch)从输入中第一个字符开始读取，二scanf(&quot; %c&quot;,&amp;ch)(%前多一个空格)则从第一个非空字符开始读取。 scanf读取成功会返回读取的项数，没有读取项或者读取的数据类型不匹配时，返回0，检测到文件末尾时，返回EOF。 4.6 printf和scanf的*修饰符#12345678910111213141516171819//varwid.c---使用变宽输出字段#include&lt;stdio.h&gt;int main(void){ unsigned width, precision; int number=256; double weight=242.6; printf(\"Enter a field width:\\n\"); scanf(\"%d\",&amp;width); printf(\"The number is:%*d:\\n\",width,number); printf(\"Now enter a width and a precision:\\n\"); scanf(\"%d %d\",&amp;width,&amp;precision); //用*代替宽度格式符合，并用参数的形式传入宽度和精度。 printf(\"Weight=%*.*f\\n\",width,precision,weight); printf(\"Done!\"); return 0;} 12345678//运行结果Enter a field width:6The number is: 256:Now enter a width and a precision:4 6Weight=242.600000Done! scanf中的*的用法不同，放在%和转换符之间时，会使得scanf跳过相应的输出项； 123456789101112/* skip2.c -- skips over first two integers of input */#include &lt;stdio.h&gt;int main(void){ int n; printf(\"Please enter three integers:\\n\"); scanf(\"%*d %*d %d\", &amp;n); printf(\"The last integer was %d\\n\", n); return 0;} 123Please enter three integers:1 2 3The last integer was 3","link":"/2020/05/06/C-primer-plus-chapter4/"}],"tags":[{"name":"C Primer Plus","slug":"C-Primer-Plus","link":"/tags/C-Primer-Plus/"}],"categories":[]}